<!doctype html>
<meta charset="utf-8">
<meta name="referrer" content="no-referrer">
<meta name="viewport" content="height=device-height,width=device-width,minimum-scale=1,maximum-scale=1,initial-scale=1,user-scalable=no">

<meta name="color-scheme" content="dark">
<meta name="theme-color" content="#6611CC">

<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text x='50%' y='50%' style='dominant-baseline:central;text-anchor:middle;font-size:100px;'>ğŸ”</text></svg>">

<script async type="module">
    //==================================================//
    // Sanitize URL and reload page                     //
    //==================================================//
    if(location.hash || location.search){
        location.replace(`${location.origin}${location.pathname}`);
    }

    //==================================================//
    // Remove external communication functions          //
    //==================================================//
    delete globalThis.fetch;
    delete globalThis.XMLHttpRequest;
    delete globalThis.WebTransport;
    delete globalThis.WebSocket;
    delete globalThis.RTCPeerConnection;
    delete globalThis.HTMLFormElement.prototype.submit;

    //==================================================//
    // Detect required features                         //
    //==================================================//
    if(!globalThis.SubtleCrypto || !globalThis.CompressionStream){
        alert("ã”ä½¿ç”¨ã®ã‚¦ã‚§ãƒ–ãƒ–ãƒ©ã‚¦ã‚¶ã¯éå¯¾å¿œã§ã™");
        stop();
    }

    //==================================================//
    // Common functions ported from other modules       //
    //==================================================//

    // Type definition
    //--------------------------------------------------

    /**
    * @description The file name and byte array pairs that make up the basic file.
    * @typedef {[string, Uint8Array]} FileInit
    */

    /**
    * @description Means the byte array after exporting `CryptoKey`.
    * @typedef {Uint8Array} PortableCryptoKey
    */

    /**
    * @description Each is `PortableCryptoKey` public/private key pair.
    * @typedef {Record<keyof CryptoKeyPair, PortableCryptoKey>} PortableCryptoKeyPair
    */

    // DOM display control
    //--------------------------------------------------

    /**
    * @description Return element from id.
    * @param {string} id
    * @return {HTMLElement}
    */
    function $id(id){
        return document.getElementById(id);
    }

    /**
    * @description Return elements from name.
    * @param {string} name
    * @return {HTMLElement[]}
    */
    function $nn(name){
        return [...document.getElementsByName(name)];
    }

    /**
    * @description Return elements from class name.
    * @param {string} name
    * @return {Element[]}
    */
    function $cn(name){
        return [...document.getElementsByClassName(name)];
    }

    /**
    * @description Show notification toast.
    * @param {string} message
    * @param {number} [color]
    */
    function dialogNotify(message, color){
        const dialog = document.createElement("dialog");
        dialog.style.position = "fixed";
        dialog.style.top = "10px";
        dialog.style.transition = "all 0.1s";
        dialog.style.border = "0";
        dialog.style.borderRadius = "8px";
        dialog.style.padding = "10px 15px";
        dialog.style.color = "#FFFFFF";
        dialog.style.backgroundColor = `#${(color ?? 0x00CACACA).toString(16).padStart(6, "0")}`;
        dialog.style.boxShadow = "2px 3px 4px 0 #0000004D";
        dialog.textContent = `\u{1F514} ${message}`;

        dialog.show();

        setTimeout(() => dialog.remove(), 5000);
        document.body.appendChild(dialog);
    }

    /**
    * @description Get of the active element in the specified radio button group.
    * @param {string} name
    * @return {HTMLInputElement=}
    */
    function radioActive(name){
        return [...$nn(name)].find(e => e instanceof HTMLInputElement && e.type === "radio" && e.checked);
    }

    // DOM file I/O
    //--------------------------------------------------

    /**
    * @description Converts the `FileList` of the HTML file API to `FileList` that is easy to handle.
    * @param {File[]|FileList|HTMLInputElement} element
    * @return {Promise<FileInit[]>}
    */
    async function parseFileList(element){
        const files = element instanceof HTMLInputElement ? element.files : element;

        return Promise.all([...files ?? []].map(async f => [f.name, new Uint8Array(await f.arrayBuffer())]));
    }

    /**
    * @description Trigger "a:download" in your script to download the file.
    * @param {string} name
    * @param {BlobPart} data
    */
    function fsWrite(name, data){
        const anchor = document.createElement("a");
        anchor.download = name;
        anchor.href = URL.createObjectURL(new Blob([data]));

        anchor.click();

        URL.revokeObjectURL(anchor.href);
    }

    // Convert text byte
    //--------------------------------------------------

    /**
    * @description Convert from unicode string to UTF-8 byte array.
    * @param {string} data
    * @return {Uint8Array}
    */
    function utfEncode(data){
        return new TextEncoder().encode(data);
    }

    /**
    * @description Convert from UTF-8 byte array to unicode string.
    * @param {Uint8Array} data
    * @return {string}
    */
    function utfDecode(data){
        return new TextDecoder().decode(data);
    }

    /**
    * @description Convert from byte array to HEX string.
    * @param {Uint8Array} data
    * @return {string}
    */
    function hexEncode(data){
        return [...data].map(n => n.toString(16).toUpperCase().padStart(2, "0")).join("");
    }

    // Codec of deflate
    //--------------------------------------------------

    /**
    * @private
    * @description (INDIRECT USE ONLY!)
    * @param {Uint8Array} data
    * @param {TransformStream<Uint8Array, Uint8Array>} ts
    * @return {Promise<Uint8Array>}
    */
    async function streamConvert(data, ts){
        return new Uint8Array(await new Response(new Blob([data]).stream().pipeThrough(ts)).arrayBuffer());
    }

    /**
    * @description Compress binary in "deflate" format (RFC1951). It does not include header information like "gzip" (RFC1952) or "zlib" (RFC1950) as it does purely "compression only".
    * @param {Uint8Array} data
    * @return {Promise<Uint8Array>}
    */
    async function deflateEncode(data){
        return await streamConvert(data, new CompressionStream("deflate-raw"));
    }

    /**
    * @description Decompress "deflate" format (RFC1951) binary. Binaries containing header information like "gzip" (RFC1952) or "zlib" (RFC1950) cannot be decompressed.
    * @param {Uint8Array} data
    * @return {Promise<Uint8Array>}
    */
    async function deflateDecode(data){
        return await streamConvert(data, new DecompressionStream("deflate-raw"));
    }

    // Codec of minipack
    //--------------------------------------------------

    const sizeHash = 32;
    const sizeName = 1;
    const sizeBody = 4;

    /**
    * @description Encode data into a byte array in "minipack" format.
    * @see https://deno.land/x/simple_utility
    * @param {FileInit[]} files
    * @return {Promise<Uint8Array>}
    */
    async function minipackEncode(files){
        const archive = new Uint8Array(files.reduce((a, [k, v]) => a + sizeHash + sizeName + sizeBody + utfEncode(k).byteLength + v.byteLength, 0));

        let offset = 0;

        for(const [k, v] of files){
            const name = utfEncode(k);
            const body = v;

            archive.set(await cryptoHash(false, body), offset);
            offset += sizeHash;

            new DataView(archive.buffer, offset).setUint8(0, name.byteLength);
            offset += sizeName;

            new DataView(archive.buffer, offset).setUint32(0, body.byteLength);
            offset += sizeBody;

            archive.set(name, offset);
            offset += name.byteLength;

            archive.set(body, offset);
            offset += body.byteLength;
        }

        return archive;
    }

    /**
    * @description Decode byte array in "minipack" format.
    * @see https://deno.land/x/simple_utility
    * @param {Uint8Array} archive
    * @return {Promise<FileInit[]>}
    */
    async function minipackDecode(archive){
        /** @type {FileInit[]} */
        const files = [];

        let offset = 0;

        while(offset < archive.byteLength){
            const hash = archive.subarray(offset, offset += sizeHash);

            const ns = new DataView(archive.buffer, offset).getUint8(0);
            offset += sizeName;

            const bs = new DataView(archive.buffer, offset).getUint32(0);
            offset += sizeBody;

            const name = utfDecode(archive.subarray(offset, offset += ns));

            const body = archive.subarray(offset, offset += bs);

            if(hexEncode(hash) !== hexEncode(await cryptoHash(false, body))){
                throw new Error();
            }

            files.push([name, body]);
        }

        return files;
    }

    // Web Crypto API
    //--------------------------------------------------

    const sizeTag = 16;
    const sizeIv = 12;

    /**
    * @private
    * @description (INDIRECT USE ONLY!)
    * @param {number} tag
    * @param {Uint8Array} iv
    * @return {AesGcmParams}
    */
    function generateAesGcmConfig(tag, iv){
        return {
            name: "AES-GCM",
            tagLength: tag * 8,
            iv: iv
        };
    }

    /**
    * @private
    * @description (INDIRECT USE ONLY!)
    * @param {boolean} isECDH
    * @return {EcKeyAlgorithm}
    */
    function generateEcKeyConfig(isECDH){
        return {
            name: isECDH ? "ECDH" : "ECDSA",
            namedCurve: "P-521"
        };
    }

    /**
    * @private
    * @description (INDIRECT USE ONLY!)
    * @return {EcdsaParams}
    */
    function generateEcDsaConfig(){
        return {
            name: "ECDSA",
            hash: {
                name: "SHA-512"
            }
        };
    }

    /**
    * @private
    * @description (INDIRECT USE ONLY!)
    * @param {PortableCryptoKeyPair} kp
    * @return {Promise<CryptoKey>}
    */
    async function deriveSecretKey(kp){
        const ec = generateEcKeyConfig(true);
        const publicKey = await crypto.subtle.importKey("spki", kp.publicKey, ec, false, []);
        const privateKey = await crypto.subtle.importKey("pkcs8", kp.privateKey, ec, false, ["deriveKey", "deriveBits"]);

        /** @type {AesDerivedKeyParams} */
        const aes = {
            name: "AES-GCM",
            length: 256
        };

        /** @type {EcdhKeyDeriveParams} */
        const dh = {
            name: "ECDH",
            public: publicKey
        };

        return await crypto.subtle.deriveKey(dh, privateKey, aes, false, ["encrypt", "decrypt"]);
    }

    /**
    * @description Returns random byte array with the specified number of bytes.
    * @param {number} size
    * @return {Uint8Array}
    */
    function cryptoRandom(size){
        return crypto.getRandomValues(new Uint8Array(size));
    }

    /**
    * @description Derive SHA2 hash value from byte array.
    * @param {boolean} is512
    * @param {Uint8Array} data
    * @return {Promise<Uint8Array>}
    */
    async function cryptoHash(is512, data){
        const sha = is512 ? "SHA-512" : "SHA-256";

        return new Uint8Array(await crypto.subtle.digest(sha, data));
    }

    /**
    * @description Generate and export public/private key pair as a portable byte array.
    * @param {boolean} isECDH
    * @return {Promise<PortableCryptoKeyPair>}
    */
    async function cryptoGenerateKey(isECDH){
        /** @type {KeyUsage[]} */
        const usage = isECDH ? ["deriveKey", "deriveBits"] : ["sign", "verify"];
        const ec = generateEcKeyConfig(isECDH);
        const {publicKey, privateKey} = await crypto.subtle.generateKey(ec, true, usage);

        return {
            publicKey: new Uint8Array(await crypto.subtle.exportKey("spki", publicKey)),
            privateKey: new Uint8Array(await crypto.subtle.exportKey("pkcs8", privateKey))
        };
    }

    /**
    * @description Encrypt byte array using AES-GCM with 256 bits key, 128 bits tag and 96 bits IV. The IV is prepended to the byte array.
    * @param {PortableCryptoKeyPair} kp
    * @param {Uint8Array} data
    * @return {Promise<Uint8Array>}
    */
    async function cryptoEncrypt(kp, data){
        const gcm = generateAesGcmConfig(sizeTag, cryptoRandom(sizeIv));
        const secretKey = await deriveSecretKey(kp);
        const output = new Uint8Array(sizeTag + sizeIv + data.byteLength);

        output.set(gcm.iv, 0);
        output.set(new Uint8Array(await crypto.subtle.encrypt(gcm, secretKey, data)), gcm.iv.byteLength);

        return output;
    }

    /**
    * @description Decrypt encrypted byte array using AES-GCM with 256 bits key 128 bits tag and 96 bits IV. Read the IV prepended to the byte array.
    * @function cryptoDecrypt
    * @param {PortableCryptoKeyPair} kp
    * @param {Uint8Array} data
    * @return {Promise<Uint8Array>}
    */
    async function cryptoDecrypt(kp, data){
        const gcm = generateAesGcmConfig(sizeTag, data.subarray(0, sizeIv));
        const secretKey = await deriveSecretKey(kp);

        return new Uint8Array(await crypto.subtle.decrypt(gcm, secretKey, data.subarray(sizeIv)));
    }

    /**
    * @description Create byte array signature using the private key and SHA2 hash algorithm.
    * @param {PortableCryptoKey} k
    * @param {Uint8Array} data
    * @return {Promise<Uint8Array>}
    */
    async function cryptoSign(k, data){
        const ec = generateEcKeyConfig(false);
        const dsa = generateEcDsaConfig();
        const privateKey = await crypto.subtle.importKey("pkcs8", k, ec, false, ["sign"]);

        return new Uint8Array(await crypto.subtle.sign(dsa, privateKey, data));
    }

    /**
    * @description Verifies the correct signature of a byte array using the public key and SHA2 hash algorithm.
    * @param {Uint8Array} signature
    * @param {PortableCryptoKey} k
    * @param {Uint8Array} data
    * @return {Promise<boolean>}
    */
    async function cryptoVerify(signature, k, data){
        const ec = generateEcKeyConfig(false);
        const dsa = generateEcDsaConfig();
        const publicKey = await crypto.subtle.importKey("spki", k, ec, false, ["verify"]);

        return await crypto.subtle.verify(dsa, publicKey, signature, data);
    }

    //==================================================//
    // Application specific functions                   //
    //==================================================//

    // General utility
    //--------------------------------------------------

    /**
    * @description Output random HEX with arbitrary number of bytes.
    * @param {number} size
    * @return {string}
    */
    function randomHex(size){
        return hexEncode(cryptoRandom(size));
    }

    /**
    * @description Clear the blob attached to the file input.
    */
    function clearInputFile(){
        /** @type {HTMLInputElement[]} */
        const inputs = $cn("j-input-file");

        for(const input of inputs){
            input.value = "";
        }
    }

    const colorGreen = 0x000CB814;
    const colorRed = 0x00E40F0F;

    // DOM Event Handler
    //--------------------------------------------------

    /**
    * @description Handle the tab switch and transition.
    * @return {()=>Promise<void>}
    */
    function handleSwitchTab(){
        return ()=>{
            for(const element of $cn("j-tab-page")){
                element.setAttribute("hidden", "");
            }

            const tab = radioActive("tab-switch")?.value;

            if(!tab){
                throw new Error();
            }

            clearInputFile();
            $id(tab).removeAttribute("hidden");
        };
    }

    /**
    * @description Handle the encrypt button.
    * @return {()=>Promise<void>}
    */
    function handleExecuteEncrypt(){
        return async()=>{
            dialogNotify("æš—å·åŒ–ã‚’é–‹å§‹ã—ã¾ã—ãŸ", colorGreen);

            try{
                const files = await parseFileList($id("encrypt-files"));
                const [publicKey] = await parseFileList($id("encrypt-public"));
                const [privateKeyE] = await parseFileList($id("encrypt-private"));
                const [privateKeyS] = await parseFileList($id("sign-private"));

                if(!files.length || !publicKey || !privateKeyE){
                    dialogNotify("ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„", colorRed);
                    return;
                }

                const id = randomHex(6);

                const archive = await minipackEncode(files);
                const compress = await deflateEncode(archive);

                if(privateKeyS){
                    const signature = await cryptoSign(privateKeyS[1], compress);

                    fsWrite(`${id}.sig`, signature);
                }

                const cipher = await cryptoEncrypt({
                    publicKey: publicKey[1],
                    privateKey: privateKeyE[1]
                }, compress);

                fsWrite(`${id}.enc`, cipher);

                dialogNotify("æš—å·åŒ–ãŒå®Œäº†ã—ã¾ã—ãŸ", colorGreen);
            }
            catch(e){
                console.error(e);
                dialogNotify("æš—å·åŒ–ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ", colorRed);
            }
            finally{
                clearInputFile();
            }
        };
    }

    /**
    * @description Handle the decrypt button.
    * @return {()=>Promise<void>}
    */
    function handleExecuteDecrypt(){
        return async()=>{
            dialogNotify("å¾©å·ã‚’é–‹å§‹ã—ã¾ã—ãŸ", colorGreen);

            try{
                const [cipher] = await parseFileList($id("decrypt-file"));
                const [publicKeyE] = await parseFileList($id("decrypt-public"));
                const [privateKey] = await parseFileList($id("decrypt-private"));
                const [publicKeyV] = await parseFileList($id("verify-public"));
                const [signature] = await parseFileList($id("verify-signature"));

                if(!cipher || !publicKeyE || !privateKey){
                    dialogNotify("ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„", colorRed);
                    return;
                }

                const compress = await cryptoDecrypt({
                    publicKey: publicKeyE[1],
                    privateKey: privateKey[1]
                }, cipher[1]);

                if(publicKeyV && signature){
                    const verify = await cryptoVerify(signature[1], publicKeyV[1], compress);

                    if(!verify){
                        clearInputFile();

                        dialogNotify("ç½²åãŒä¸€è‡´ã—ãªã„ãŸã‚å¾©å·ã‚’ä¸­æ­¢ã—ã¾ã—ãŸ", colorRed);
                        return;
                    }
                }

                const archive = await deflateDecode(compress);
                const files = await minipackDecode(archive);

                for(const [name, body] of files){
                    fsWrite(name, body);
                }

                dialogNotify("å¾©å·ãŒå®Œäº†ã—ã¾ã—ãŸ", colorGreen);
            }
            catch(e){
                console.error(e);
                dialogNotify("å¾©å·ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ", colorRed);
            }
            finally{
                clearInputFile();
            }
        };
    }

    /**
    * @description Handle the key generation button.
    * @param {boolean} isEncrypt
    * @return {()=>Promise<void>}
    */
    function handleGenerateKey(isEncrypt){
        return async()=>{
            const type = isEncrypt ? "enc" : "sig";

            dialogNotify("éµç”Ÿæˆã‚’é–‹å§‹ã—ã¾ã—ãŸ", colorGreen);

            try{
                const {publicKey, privateKey} = await cryptoGenerateKey(isEncrypt);

                const id = randomHex(6);

                fsWrite(`${id}.${type}.pubkey`, publicKey);
                fsWrite(`${id}.${type}.prikey`, privateKey);

                dialogNotify("éµç”ŸæˆãŒå®Œäº†ã—ã¾ã—ãŸ", colorGreen);
            }
            catch(e){
                console.error(e);
                dialogNotify("éµç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ", colorRed);
            }
        };
    }

    // Registration DOM Event Handlers
    //--------------------------------------------------

    for(const element of $nn("tab-switch")){
        element.onchange = handleSwitchTab();
    }

    $id("execute-encrypt").onclick = handleExecuteEncrypt();
    $id("execute-decrypt").onclick = handleExecuteDecrypt();
    $id("generate-encrypt").onclick = handleGenerateKey(true);
    $id("generate-sign").onclick = handleGenerateKey(false);

    window.onload = ()=>{
        document.body.removeAttribute("hidden");
    };
</script>

<style>
    /* Variables
    --------------------------------------------------*/
    :root{
        --header-height-1: 48px;
        --header-height-2: 36px;
        --header-height-total: calc(var(--header-height-1) + var(--header-height-2));
        --main-height: calc(100dvh - var(--header-height-total));
    }

    /* Meta Property
    --------------------------------------------------*/
    ::-webkit-scrollbar{
        display: none !important;
    }
    ::file-selector-button{
        display: none !important;
    }
    :focus{
        outline: none !important;
    }

    /* Tag Specific Value
    --------------------------------------------------*/
    body{
        user-select: none !important;
        margin: 0 !important;
        padding: 0 !important;
    }
    header,
    main{
        position: fixed;
        box-sizing: border-box;
        width: 100dvw;
        color: #FFFFFF;
    }
    header{
        top: 0px;
        height: var(--header-height-total);
        overflow: hidden;
        background-color: #7811FF;
    }
    main{
        top: var(--header-height-total);
        height: var(--main-height);
        background-color: #303030;
        overflow-y: scroll;
    }
    header > nav{
        display: flex;
        align-items: center;
        box-sizing: border-box;
        width: 100%;
    }
    header > nav:nth-of-type(1){
        height: var(--header-height-1);
        padding: 0 12px;
    }
    header > nav:nth-of-type(2){
        height: var(--header-height-2);
        justify-content: center;
    }
    main > article{
        box-sizing: border-box;
        padding: 12px;
        width: 100%;
    }
    input,
    label,
    button{
        box-sizing: border-box;
        border: none;
        cursor: pointer;
        -webkit-tap-highlight-color: #00000000;
    }
    code{
        padding: 0 2px;
        border-radius: 2px;
        background-color: #505050;
    }

    /* Custom Selector
    --------------------------------------------------*/
    .c-flex-center{
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .c-title-1{
        margin: 0;
        font-size: 28px;
    }
    .c-title-2{
        margin: 4px 0 16px 0;
        font-size: 22px;
    }
    .c-tab-button{
        height: 100%;
        width: calc(100dvw / 4);
        max-width: 200px;
    }
    .c-tab-button > label{
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 16px;
        height: 100%;
    }
    .c-tab-button > label:hover{
        background-color: #8639FF;
    }
    .c-tab-button > label:active{
        background-color: #9856F8;
    }
    .c-tab-button > input:checked + label{
        background-color: #904EFD;
    }
    .c-input-list{
        list-style: none;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        margin: 0;
        padding: 0;
    }
    .c-input-file{
        display: flex;
        align-items: center;
        justify-content: center;
        height: 28px;
        width: 400px;
        max-width: calc(100dvw - 40px);
        margin: 4px 0;
        padding: 4px;
        border-radius: 4px;
        background-color: #444444;
    }
    .c-input-file:hover{
        background-color: #555555;
    }
    .c-input-file:active{
        background-color: #777777;
    }
    .c-input-file > label,
    .c-input-file > input{
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        width: calc(100% / 2);
    }
    .c-start-button{
        font-size: 20px;
        margin: 8px;
        padding: 0;
        height: 36px;
        width: 100%;
        max-width: 180px;
        color: #FFFFFF;
        border-radius: 4px;
        background-color: #2299FF;
    }
    .c-start-button:hover{
        background-color: #39B3FF;
    }
    .c-start-button:active{
        background-color: #77CCFF;
    }
</style>

<title>å…¬é–‹éµæš—å·åŒ–ãƒ„ãƒ¼ãƒ«</title>

<header>
    <nav>
        <h1 class="c-title-1 c-flex-center">å…¬é–‹éµæš—å·åŒ–ãƒ„ãƒ¼ãƒ«</h1>
    </nav>

    <nav>
        <div class="c-tab-button">
            <input hidden checked type="radio" name="tab-switch" id="tab-switch-1" value="tab-1">
            <label for="tab-switch-1">æš—å·åŒ–</label>
        </div>

        <div class="c-tab-button">
            <input hidden type="radio" name="tab-switch" id="tab-switch-2" value="tab-2">
            <label for="tab-switch-2">å¾©å·</label>
        </div>

        <div class="c-tab-button">
            <input hidden type="radio" name="tab-switch" id="tab-switch-3" value="tab-3">
            <label for="tab-switch-3">éµç”Ÿæˆ</label>
        </div>

        <div class="c-tab-button">
            <input hidden type="radio" name="tab-switch" id="tab-switch-4" value="tab-4">
            <label for="tab-switch-4">ãƒ˜ãƒ«ãƒ—</label>
        </div>
    </nav>
</header>

<main>
    <article class="j-tab-page" id="tab-1">
        <h2 class="c-title-2 c-flex-center">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æš—å·åŒ–</h2>

        <ul class="c-input-list">
            <li>
                <div class="c-input-file">
                    <label for="encrypt-files">æš—å·åŒ–å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«</label>
                    <input multiple type="file" class="j-input-file" id="encrypt-files">
                </div>
            </li>

            <li>
                <div class="c-input-file">
                    <label for="encrypt-public">å…¬é–‹éµ</label>
                    <input type="file" accept=".enc.pubkey" class="j-input-file" id="encrypt-public">
                </div>
            </li>

            <li>
                <div class="c-input-file">
                    <label for="encrypt-private">ç§˜å¯†éµ</label>
                    <input type="file" accept=".enc.prikey" class="j-input-file" id="encrypt-private">
                </div>
            </li>

            <li>
                <div class="c-input-file">
                    <label for="sign-private">ç½²åç§˜å¯†éµ (ä»»æ„)</label>
                    <input type="file" accept=".sig.prikey" class="j-input-file" id="sign-private">
                </div>
            </li>
        </ul>

        <section class="c-flex-center">
            <button type="button" class="c-start-button" id="execute-encrypt">&#x1F512;æš—å·åŒ–</button>
        </section>
    </article>

    <article hidden class="j-tab-page" id="tab-2">
        <h2 class="c-title-2 c-flex-center">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¾©å·</h2>

        <ul class="c-input-list">
            <li>
                <div class="c-input-file">
                    <label for="decrypt-file">æš—å·ãƒ•ã‚¡ã‚¤ãƒ«</label>
                    <input type="file" accept=".enc" class="j-input-file" id="decrypt-file">
                </div>
            </li>

            <li>
                <div class="c-input-file">
                    <label for="decrypt-public">å…¬é–‹éµ</label>
                    <input type="file" accept=".enc.pubkey" class="j-input-file" id="decrypt-public">
                </div>
            </li>

            <li>
                <div class="c-input-file">
                    <label for="decrypt-private">ç§˜å¯†éµ</label>
                    <input type="file" accept=".enc.prikey" class="j-input-file" id="decrypt-private">
                </div>

            </li>

            <li>
                <div class="c-input-file">
                    <label for="verify-signature">é›»å­ç½²å (ä»»æ„)</label>
                    <input type="file" accept=".sig" class="j-input-file" id="verify-signature">
                </div>
            </li>

            <li>
                <div class="c-input-file">
                    <label for="verify-public">ç½²åå…¬é–‹éµ (ä»»æ„)</label>
                    <input type="file" accept=".sig.pubkey" class="j-input-file" id="verify-public">
                </div>
            </li>
        </ul>

        <section class="c-flex-center">
            <button type="button" class="c-start-button" id="execute-decrypt">&#x1F513;å¾©å·</button>
        </section>
    </article>

    <article hidden class="j-tab-page" id="tab-3">
        <h2 class="c-title-2 c-flex-center">éµã‚’ç”Ÿæˆ</h2>

        <section class="c-flex-center">
            <button type="button" class="c-start-button" id="generate-encrypt">&#x1F511;æš—å·åŒ–éµç”Ÿæˆ</button>
            <button type="button" class="c-start-button" id="generate-sign">&#x1F511;ç½²åéµç”Ÿæˆ</button>
        </section>
    </article>

    <article hidden class="j-tab-page" id="tab-4">
        <h2 class="c-title-2 c-flex-center">ä½¿ç”¨æ–¹æ³•</h2>

        <section>
            <h3>STEP0: ç½²åéµã‚’ç”Ÿæˆã™ã‚‹ (ä»»æ„) (æ“ä½œ: é€ä¿¡è€…)</h3>

            <ol>
                <li>ç½²åãŒä¸è¦ãªå ´åˆã¯ã€æœ¬æ‰‹é †ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—æ¬¡ã®æ‰‹é †ã¸é€²ã¿ã¾ã™ã€‚</li>
                <li>é€ä¿¡è€…ã¯ã€æœ€åˆã« <a href="#sign-generate">ç½²åéµç”Ÿæˆãƒœã‚¿ãƒ³</a> ã‚’æŠ¼ã—ã€å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™ã€‚</li>
                <li>å‡¦ç†ãŒå®Œäº†ã™ã‚‹ã¨ã€2å€‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã™ã€‚(è¨±å¯ã‚’è¦æ±‚ã•ã‚ŒãŸå ´åˆã¯è¨±å¯ã—ã¾ã™)</li>
                <ul>
                    <li><code>{ä¹±æ•°}.sign.pub</code> : å…¬é–‹éµ (å…¬é–‹ã—ã¦ã‚‚å•é¡Œãªã„)</li>
                    <li><code>{ä¹±æ•°}.sign.sec</code> : ç§˜å¯†éµ (çµ¶å¯¾ã«å…¬é–‹ã—ã¦ã¯ã„ã‘ãªã„)</li>
                </ul>
                <li>ç”Ÿæˆã—ãŸ <code>{ä¹±æ•°}.sign.pub</code> ã‚’ä»»æ„ã®æ–¹æ³•ã§å—ä¿¡è€…ã¸é€ä¿¡ã—ã¾ã™ã€‚</li>
                <ul>
                    <li>ç½²åéµã¯ã€ç§˜å¯†éµã®ç´›å¤±ã‚„æ¼æ´©ãŒç„¡ã„é™ã‚Šå†åˆ©ç”¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚</li>
                    <li>é€ä¿¡æ–¹æ³•ã¯ã€å¾Œè¿°ã®æš—å·åŒ–ãƒ•ã‚¡ã‚¤ãƒ«ã®é€ä¿¡ã§ä½¿ç”¨ã™ã‚‹æ–¹æ³•ã¨ã¯åˆ¥ã®æ–¹æ³•ã‚’æ¨å¥¨ã—ã¾ã™ã€‚</li>
                </ul>
            </ol>
        </section>

        <section>
            <h3>STEP1: æš—å·åŒ–éµã‚’ç”Ÿæˆã™ã‚‹ (æ“ä½œ: é€ä¿¡è€…/å—ä¿¡è€…)</h3>

            <ol>
                <li>é€ä¿¡è€…ã¨å—ä¿¡è€…ã¯ã€ãã‚Œãã‚Œ <a href="#encrypt-generate">æš—å·åŒ–éµç”Ÿæˆãƒœã‚¿ãƒ³</a> ã‚’æŠ¼ã—ã€å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™ã€‚</li>
                <li>å‡¦ç†ãŒå®Œäº†ã™ã‚‹ã¨ã€2å€‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã™ã€‚(è¨±å¯ã‚’è¦æ±‚ã•ã‚ŒãŸå ´åˆã¯è¨±å¯ã—ã¾ã™)</li>
                <ul>
                    <li><code>{ä¹±æ•°}.encrypt.pub</code> : å…¬é–‹éµ (å…¬é–‹ã—ã¦ã‚‚å•é¡Œãªã„)</li>
                    <li><code>{ä¹±æ•°}.encrypt.sec</code> : ç§˜å¯†éµ (çµ¶å¯¾ã«å…¬é–‹ã—ã¦ã¯ã„ã‘ãªã„)</li>
                </ul>
                <li>é€ä¿¡è€…ã¨å—ä¿¡è€…ã¯ã€ãã‚Œãã‚Œç”Ÿæˆã—ãŸ <code>{ä¹±æ•°}.encrypt.pub</code> ã‚’ã€é›»å­ãƒ¡ãƒ¼ãƒ«ãªã©ã§ç›¸äº’ã«äº¤æ›ã—ã¾ã™ã€‚</li>
                <ul>
                    <li>æš—å·åŒ–éµã¯ã€å†åˆ©ç”¨ã›ãšéƒ½åº¦ç”Ÿæˆã‚’æ¨å¥¨ã—ã¾ã™ã€‚</li>
                </ul>
            </ol>
        </section>

        <section>
            <h3>STEP2: æš—å·åŒ–ã‚’è¡Œã† (æ“ä½œ: é€ä¿¡è€…)</h3>

            <ol>
                <li>é€ä¿¡è€…ã¯ã€ãƒ„ãƒ¼ãƒ«ã®å„ãƒ•ã‚©ãƒ¼ãƒ ã¸ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å…¥åŠ›ã—ã¾ã™ã€‚</li>
                <ul>
                    <li><a href="#encrypt-files">ãƒ‡ãƒ¼ã‚¿</a> : æš—å·åŒ–ã—ãŸã„ãƒ•ã‚¡ã‚¤ãƒ« (è¤‡æ•°æŒ‡å®šå¯èƒ½)</li>
                    <li><a href="#encrypt-public">å…¬é–‹éµ</a> : <code>{ä¹±æ•°}.encrypt.pub</code> (å—ä¿¡è€…ã‹ã‚‰å—ã‘å–ã£ãŸã‚‚ã®)</li>
                    <li><a href="#encrypt-secret">ç§˜å¯†éµ(æš—å·åŒ–)</a> : <code>{ä¹±æ•°}.encrypt.sec</code> (è‡ªèº«ã§ç”Ÿæˆã—ãŸã‚‚ã®)</li>
                    <li><a href="#sign-secret">ç§˜å¯†éµ(ç½²å/ä»»æ„)</a> : <code>{ä¹±æ•°}.sign.sec</code> (è‡ªèº«ã§ç”Ÿæˆã—ãŸã‚‚ã®)</li>
                </ul>
                <li><a href="#encrypt-execute">æš—å·åŒ–</a> ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã€å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™ã€‚</li>
                <li>å‡¦ç†ãŒå®Œäº†ã™ã‚‹ã¨ã€1å€‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã™ã€‚</li>
                <ul>
                    <li><code>{ä¹±æ•°}.cipher.bin</code> : æš—å·ãƒ‡ãƒ¼ã‚¿ (å…¬é–‹ã—ã¦ã‚‚å•é¡Œãªã„)</li>
                </ul>
                <li>é€ä¿¡è€…ã¯ã€æš—å·åŒ–ã•ã‚ŒãŸ <code>{ä¹±æ•°}.cipher.bin</code> ã‚’ã€é›»å­ãƒ¡ãƒ¼ãƒ«ãªã©ä»»æ„ã®æ–¹æ³•ã§å—ä¿¡è€…ã¸é€ä¿¡ã—ã¾ã™ã€‚</li>
            </ol>
        </section>

        <section>
            <h3>STEP3: æš—å·ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å·ã™ã‚‹ (æ“ä½œ: å—ä¿¡è€…)</h3>

            <ol>
                <li>å—ä¿¡è€…ã¯ã€ãƒ„ãƒ¼ãƒ«ã®å„ãƒ•ã‚©ãƒ¼ãƒ ã¸ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å…¥åŠ›ã—ã¾ã™ã€‚</li>
                <ul>
                    <li><a href="#decrypt-file">ãƒ‡ãƒ¼ã‚¿</a> : <code>{ä¹±æ•°}.cipher.bin</code> (é€ä¿¡è€…ã‹ã‚‰å—ã‘å–ã£ãŸã‚‚ã®)</li>
                    <li><a href="#decrypt-public">å…¬é–‹éµ(å¾©å·)</a> : <code>{ä¹±æ•°}.encrypt.pub</code> (é€ä¿¡è€…ã‹ã‚‰å—ã‘å–ã£ãŸã‚‚ã®)</li>
                    <li><a href="#decrypt-secret">ç§˜å¯†éµ</a> : <code>{ä¹±æ•°}.encrypt.sec</code> (è‡ªèº«ã§ç”Ÿæˆã—ãŸã‚‚ã®)</li>
                    <li><a href="#verify-public">å…¬é–‹éµ(æ¤œè¨¼/ä»»æ„)</a> : <code>{ä¹±æ•°}.sign.pub</code> (é€ä¿¡è€…ã‹ã‚‰å—ã‘å–ã£ãŸã‚‚ã®)</li>
                </ul>
                <li><a href="#decrypt-execute">å¾©å·</a> ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã€å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™ã€‚</li>
                <li>å‡¦ç†ãŒå®Œäº†ã™ã‚‹ã¨ã€å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã™ã€‚(è¨±å¯ã‚’è¦æ±‚ã•ã‚ŒãŸå ´åˆã¯è¨±å¯ã—ã¾ã™)</li>
            </ol>
        </section>

        <h2 class="c-title-2">æŠ€è¡“ä»•æ§˜</h2>

        <section>
            <ul>
                <li>å®Ÿè£…: <a target="_blank" rel="noopener" href="https://www.w3.org/TR/WebCryptoAPI">Web Crypto API</a></li>
                <li>éµäº¤æ›: <a target="_blank" rel="noopener" href="https://ja.wikipedia.org/wiki/æ¥•å††æ›²ç·šãƒ‡ã‚£ãƒ•ã‚£ãƒ¼ãƒ»ãƒ˜ãƒ«ãƒãƒ³éµå…±æœ‰">ECDH</a></li>
                <li>ç½²å: <a target="_blank" rel="noopener" href="https://ja.wikipedia.org/wiki/æ¥•å††æ›²ç·šDSA">ECDSA</a></li>
                <li>å…¬é–‹éµãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿: <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc4492">NIST P-521</a> - 521bit Key</li>
                <li>å…±é€šéµæš—å·: <a target="_blank" rel="noopener" href="https://ja.wikipedia.org/wiki/Advanced_Encryption_Standard">AES-GCM</a> - 256bit Key, 128bit Tag, 128bit IV</li>
            </ul>
        </section>

        <h2 class="c-title-2">å®‰å…¨æ€§</h2>

        <section>
            <ul>
                <li>ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã¯ãƒ­ãƒ¼ã‚«ãƒ«ã§å®Œçµã™ã‚‹ãŸã‚ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆé€šä¿¡ã‚’ä¼´ã†å‡¦ç†ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</li>
                <li>ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£è£½ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ä½¿ç”¨ã—ã¦ã„ã¾ã›ã‚“ã€‚</li>
                <li>MITãƒ©ã‚¤ã‚»ãƒ³ã‚¹æº–æ‹ ã®ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã¨ãªã‚Šã¾ã™ã€‚</li>
                <li>ãƒãƒƒã‚·ãƒ¥å€¤: <a target="_blank" rel="noopener" href="https://dojyorin.github.io/web-crypto/hash.txt">SHA512</a></li>
                <li>ãƒªãƒã‚¸ãƒˆãƒª: <a target="_blank" rel="noopener" href="https://github.com/dojyorin/web-crypto">GitHub</a></li>
                <li>ãŠå•ã„åˆã‚ã›: <a target="_blank" rel="noopener" href="https://twitter.com/dojyorin">Twitter</a></li>
            </ul>
        </section>
    </article>
</main>